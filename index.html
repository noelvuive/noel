<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHÀO 2026 - BOSS BON VINH</title>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
        canvas { position: absolute; top: 0; left: 0; }
        #text-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 80px; font-weight: bold; text-align: center;
            z-index: 10; pointer-events: none; text-shadow: 0 0 20px rgba(255,255,255,0.8);
        }
        .wish-text { font-size: 24px !important; color: #ffcccc !important; width: 80%; }
    </style>
</head>
<body>

<div id="text-overlay"></div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const textOverlay = document.getElementById('text-overlay');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particles = [];
    const wishes = [
        "Chúc mừng năm mới 2026!",
        "Chúc bạn một năm đầy hy vọng và thành công.",
        "Mọi ước mơ của bạn sẽ trở thành hiện thực.",
        "Hạnh phúc, bình an và luôn nở nụ cười trên môi.",
        "Chào đón 2026 với những điều rực rỡ nhất!"
    ];

    // Hàm tạo hiệu ứng gõ chữ
    async function typeText(text, delay = 100) {
        textOverlay.innerText = "";
        for (let i = 0; i < text.length; i++) {
            textOverlay.innerText += text[i];
            await new Promise(r => setTimeout(r, delay));
        }
    }

    // Hàm tạo hạt tan biến
    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.size = Math.random() * 3 + 1;
            this.vx = (Math.random() - 0.5) * 10;
            this.vy = (Math.random() - 0.5) * 10;
            this.life = 1;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.life -= 0.02;
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    function explode() {
        for(let i=0; i<100; i++) {
            particles.push(new Particle(canvas.width/2, canvas.height/2, '#fff'));
        }
    }

    // Vẽ và tô màu trái tim
    function drawHeartShape(scale) {
        ctx.beginPath();
        ctx.fillStyle = "red";
        ctx.shadowBlur = 30;
        ctx.shadowColor = "red";
        for (let t = 0; t <= Math.PI * 2; t += 0.01) {
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
            ctx.lineTo(canvas.width/2 + x * scale, canvas.height/2 + y * scale);
        }
        ctx.fill();
    }

    async function startFlow() {
        // 1. Đếm ngược 3 2 1 tan biến
        for (let i = 3; i > 0; i--) {
            textOverlay.innerText = i;
            await new Promise(r => setTimeout(r, 800));
            explode();
            textOverlay.innerText = "";
            await new Promise(r => setTimeout(r, 200));
        }

        // 2. Gõ chữ 2026
        await typeText("2026", 200);
        await new Promise(r => setTimeout(r, 1000));
        explode();
        textOverlay.innerText = "";

        // 3. Vẽ và tô màu trái tim
        let scale = 0;
        while(scale < 15) {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            drawHeartShape(scale);
            scale += 0.5;
            await new Promise(r => requestAnimationFrame(r));
        }
        await new Promise(r => setTimeout(r, 1000));

        // 4. Trái tim tan biến 3D
        for(let i=0; i<500; i++) {
            particles.push(new Particle(canvas.width/2 + (Math.random()-0.5)*300, canvas.height/2 + (Math.random()-0.5)*300, 'red'));
        }
        
        let heartAlpha = 1;
        while(heartAlpha > 0) {
            ctx.clearRect(0,0, canvas.width, canvas.height);
            ctx.globalAlpha = heartAlpha;
            drawHeartShape(15);
            heartAlpha -= 0.05;
            await new Promise(r => requestAnimationFrame(r));
        }

        // 5. Hiện lời chúc gõ máy tính và tan biến
        textOverlay.classList.add('wish-text');
        for (let wish of wishes) {
            await typeText(wish, 80);
            await new Promise(r => setTimeout(r, 2000));
            explode();
            textOverlay.innerText = "";
            await new Promise(r => setTimeout(r, 500));
        }
    }

    function animationLoop() {
        if (particles.length > 0) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => { p.update(); p.draw(); });
        }
        requestAnimationFrame(animationLoop);
    }

    animationLoop();
    startFlow();
</script>
</body>
</html>

