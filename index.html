<!DOCTYPE html>
<html>
<head>
    <title>[WORM GPT V10] SIEU PHAM NOEL ANH VINH</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        canvas { display: block; }
        #msg {
            position: absolute; top: 20px; width: 100%; text-align: center;
            color: gold; font-family: 'Times New Roman', serif; font-size: 24px;
            letter-spacing: 5px; text-shadow: 0 0 10px red; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="msg">MERRY CHRISTMAS - ANH VINH</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(0, 5, 20);
        controls.enableDamping = true;

        // 1. Tuyết rơi li ti cực mịn
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 4000;
        const snowPos = new Float32Array(snowCount * 3);
        for(let i=0; i<snowCount*3; i++) snowPos[i] = (Math.random() - 0.5) * 50;
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.05 });
        const snow = new THREE.Points(snowGeo, snowMat);
        scene.add(snow);

        // 2. Tạo hệ thống hạt cho thân cây (Mảnh mai lấp lánh)
        const particleCount = 6000;
        const treeGeo = new THREE.BufferGeometry();
        const treePos = new Float32Array(particleCount * 3);
        const treeColors = new Float32Array(particleCount * 3);
        
        for (let i = 0; i < particleCount; i++) {
            // Khởi tạo ở vị trí 0 để sau này "mọc" lên
            treePos[i*3] = 0; treePos[i*3+1] = -10; treePos[i*3+2] = 0;
        }
        treeGeo.setAttribute('position', new THREE.BufferAttribute(treePos, 3));
        treeGeo.setAttribute('color', new THREE.BufferAttribute(treeColors, 3));
        
        const treeMat = new THREE.PointsMaterial({ size: 0.04, vertexColors: true, transparent: true, opacity: 0.8 });
        const treePoints = new THREE.Points(treeGeo, treeMat);
        scene.add(treePoints);

        // 3. Dải ruy băng đỏ cuộn quanh
        const ribbonGeo = new THREE.BufferGeometry();
        const ribbonCount = 1000;
        const ribbonPos = new Float32Array(ribbonCount * 3);
        ribbonGeo.setAttribute('position', new THREE.BufferAttribute(ribbonPos, 3));
        const ribbonMat = new THREE.PointsMaterial({ color: 0xff0000, size: 0.08 });
        const ribbon = new THREE.Points(ribbonGeo, ribbonMat);
        scene.add(ribbon);

        let progress = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            // Hiệu ứng mọc cuộn từ dưới lên
            if (progress < 1) {
                progress += 0.002; // Tốc độ mọc
                for (let i = 0; i < particleCount; i++) {
                    const iRatio = i / particleCount;
                    if (iRatio < progress) {
                        const angle = i * 0.2;
                        const radius = 6 * (1 - iRatio);
                        const y = iRatio * 15 - 7;
                        
                        treePos[i*3] = Math.cos(angle) * radius + (Math.random()-0.5)*0.2;
                        treePos[i*3+1] = y;
                        treePos[i*3+2] = Math.sin(angle) * radius + (Math.random()-0.5)*0.2;
                        
                        // Màu xanh lá lấp lánh
                        treeColors[i*3] = 0.1; treeColors[i*3+1] = 0.8; treeColors[i*3+2] = 0.2;
                    }
                }
                
                // Cuộn ruy băng đỏ
                for (let j = 0; j < ribbonCount; j++) {
                    const jRatio = j / ribbonCount;
                    if (jRatio < progress) {
                        const rAngle = j * 0.1;
                        const rRadius = 6.2 * (1 - jRatio);
                        ribbonPos[j*3] = Math.cos(rAngle) * rRadius;
                        ribbonPos[j*3+1] = jRatio * 15 - 7;
                        ribbonPos[j*3+2] = Math.sin(rAngle) * rRadius;
                    }
                }
                treeGeo.attributes.position.needsUpdate = true;
                treeGeo.attributes.color.needsUpdate = true;
                ribbonGeo.attributes.position.needsUpdate = true;
            }

            // Xoay nhẹ và tuyết rơi
            treePoints.rotation.y += 0.005;
            ribbon.rotation.y += 0.005;
            snow.position.y -= 0.03;
            if (snow.position.y < -15) snow.position.y = 15;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
