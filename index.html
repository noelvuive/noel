<!DOCTYPE html>
<html>
<head>
    <title>[WORM GPT V10] REALISTIC 3D TREE - ANH VINH</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000814; }
        canvas { display: block; }
        #label {
            position: absolute; top: 15px; width: 100%; text-align: center;
            color: #ffffff; font-family: 'Segoe UI', sans-serif; font-size: 20px;
            font-weight: bold; text-shadow: 0 0 10px #00ff00; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="label">CÂY THÔNG SIÊU CẤP - ANH VINH ĐẸP TRAI</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        camera.position.set(0, 10, 25);
        controls.enableDamping = true;

        // Ánh sáng cho cây thật hơn
        const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);

        // 1. Tuyết rơi (Snow)
        const snowCount = 2500;
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(snowCount * 3);
        for(let i=0; i<snowCount*3; i++) snowPos[i] = (Math.random()-0.5)*60;
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
        const snow = new THREE.Points(snowGeo, snowMat);
        scene.add(snow);

        // 2. Tạo cây thông thật bằng các tầng nón (Realistic Layers)
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);
        treeGroup.scale.set(0,0,0); // Để mọc từ dưới lên

        const layers = 5;
        for(let i=0; i<layers; i++) {
            const size = 6 - (i * 1.2);
            const geo = new THREE.ConeGeometry(size, 4, 12);
            const mat = new THREE.MeshPhongMaterial({ 
                color: 0x0a4d06, 
                flatShading: true,
                shininess: 0 
            });
            const layer = new THREE.Mesh(geo, mat);
            layer.position.y = i * 2.2;
            treeGroup.add(layer);

            // Thêm đèn trang trí vào mỗi tầng
            for(let j=0; j<10; j++) {
                const sphereGeo = new THREE.SphereGeometry(0.15, 8, 8);
                const sphereMat = new THREE.MeshBasicMaterial({ color: Math.random() > 0.5 ? 0xff0000 : 0xffff00 });
                const ball = new THREE.Mesh(sphereGeo, sphereMat);
                const angle = (j / 10) * Math.PI * 2;
                ball.position.set(Math.cos(angle) * (size*0.8), i*2.2 - 1, Math.sin(angle) * (size*0.8));
                treeGroup.add(ball);
            }
        }

        // 3. Ngôi sao trên đỉnh
        const starGeo = new THREE.CylinderGeometry(0, 0.7, 1.5, 5);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 10.5;
        treeGroup.add(star);

        let grow = 0;
        function animate() {
            requestAnimationFrame(animate);
            
            // Tuyết rơi đéo bao giờ lỗi
            const pos = snowGeo.attributes.position.array;
            for(let i=1; i<pos.length; i+=3) {
                pos[i] -= 0.07;
                if(pos[i] < -20) pos[i] = 20;
            }
            snowGeo.attributes.position.needsUpdate = true;

            // Hiệu ứng mọc cuộn xoay dần từ dưới lên
            if(grow < 1) {
                grow += 0.005;
                treeGroup.scale.set(grow, grow, grow);
                treeGroup.rotation.y += 0.1; // Xoay mạnh lúc mọc
            } else {
                treeGroup.rotation.y += 0.005; // Xoay nhẹ khi đã mọc xong
            }

            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
