<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CHÀO 2026 - BOSS BON VINH</title>
    <style>
        body, html { 
            margin: 0; padding: 0; width: 100%; height: 100%; 
            background: #000; overflow: hidden; 
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        canvas { position: absolute; top: 0; left: 0; z-index: 5; }
        #text-overlay {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #fff; font-size: 50px; font-weight: bold; text-align: center;
            z-index: 10; pointer-events: none; width: 90%;
            letter-spacing: 15px; /* Tăng khoảng cách chữ cực mạnh */
            text-transform: uppercase;
        }
        .wish-text { 
            font-size: 22px !important; 
            color: #ff4d4d !important; 
            letter-spacing: 3px !important; /* Lời chúc thoáng */
            line-height: 1.6;
            font-weight: normal !important;
            text-transform: none !important;
        }
        #pen {
            position: absolute; font-size: 35px; z-index: 20;
            display: none; pointer-events: none;
            margin-top: -30px; margin-left: 5px;
        }
    </style>
</head>
<body>

<div id="text-overlay"></div>
<div id="pen">✏️</div>
<canvas id="canvas"></canvas>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const textOverlay = document.getElementById('text-overlay');
    const pen = document.getElementById('pen');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    let particles = [];
    let heartPoints = [];
    const wishes = [
        "Chúc mừng năm mới 2026 rực rỡ",
        "Mọi dự định sẽ thành hiện thực",
        "Sức khỏe dồi dào, vạn sự bình an",
        "Luôn rạng rỡ và hạnh phúc mỗi ngày",
        "Chào đón 2026 - Một năm bùng nổ"
    ];

    // Khởi tạo tọa độ trái tim
    for (let t = 0; t <= Math.PI * 2; t += 0.05) {
        const x = 16 * Math.pow(Math.sin(t), 3);
        const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
        heartPoints.push({ x: x * 10 + canvas.width/2, y: y * 10 + canvas.height/2 });
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            this.size = Math.random() * 3 + 1;
            this.vx = (Math.random() - 0.5) * 12;
            this.vy = (Math.random() - 0.5) * 12;
            this.life = 1;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.life -= 0.02;
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    async function typeText(text, delay = 150) {
        textOverlay.innerText = "";
        for (let i = 0; i < text.length; i++) {
            textOverlay.innerText += text[i];
            await new Promise(r => setTimeout(r, delay));
        }
    }

    function explode(x, y, color) {
        for(let i=0; i<80; i++) particles.push(new Particle(x, y, color));
    }

    async function startFlow() {
        // 1. Đếm ngược 3 2 1
        for (let i = 3; i > 0; i--) {
            textOverlay.innerText = i;
            await new Promise(r => setTimeout(r, 800));
            explode(canvas.width/2, canvas.height/2, '#fff');
            textOverlay.innerText = "";
            await new Promise(r => setTimeout(r, 200));
        }

        // 2. Gõ 2026
        await typeText("2026", 250);
        await new Promise(r => setTimeout(r, 1000));
        explode(canvas.width/2, canvas.height/2, '#00ff00');
        textOverlay.innerText = "";

        // 3. Hiện bút và vẽ trái tim
        pen.style.display = "block";
        await new Promise(r => setTimeout(r, 1000));

        ctx.strokeStyle = "red";
        ctx.lineWidth = 4;
        ctx.beginPath();
        for (let p of heartPoints) {
            ctx.lineTo(p.x, p.y);
            ctx.stroke();
            pen.style.left = p.x + "px";
            pen.style.top = p.y + "px";
            await new Promise(r => setTimeout(r, 30));
        }
        
        // Tô màu
        ctx.fillStyle = "red";
        ctx.fill();
        pen.style.display = "none";
        await new Promise(r => setTimeout(r, 1500));

        // 4. Tan biến trái tim
        for(let p of heartPoints) {
            if(Math.random() > 0.5) explode(p.x, p.y, 'red');
        }
        ctx.clearRect(0,0, canvas.width, canvas.height);

        // 5. Hiện lời chúc
        textOverlay.classList.add('wish-text');
        for (let wish of wishes) {
            await typeText(wish, 100);
            await new Promise(r => setTimeout(r, 2500));
            explode(canvas.width/2, canvas.height/2, '#ff4d4d');
            textOverlay.innerText = "";
            await new Promise(r => setTimeout(r, 1000));
        }
    }

    function animationLoop() {
        // Chỉ xóa phần hạt để giữ lại hình vẽ trái tim lúc đang vẽ
        ctx.save();
        ctx.globalCompositeOperation = 'destination-out';
        ctx.fillStyle = 'rgba(0,0,0,0.1)'; 
        // ctx.fillRect(0,0,canvas.width, canvas.height); // Bỏ cái này để trái tim không bị mờ
        ctx.restore();

        // Vẽ particles
        // Ta dùng một canvas phụ hoặc clear thông minh để giữ trái tim
        // Để đơn giản, em cho tan biến là xóa hết rồi hiện hạt.
        if(particles.length > 0) {
            // Chỉ clear vùng chứa hạt hoặc clear toàn bộ nếu cần tan biến
            particles = particles.filter(p => p.life > 0);
            particles.forEach(p => { p.update(); p.draw(); });
        }
        requestAnimationFrame(animationLoop);
    }

    animationLoop();
    startFlow();
</script>
</body>
</html>
